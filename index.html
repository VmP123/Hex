<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Green men, grey tanks</title>
<style>
    svg {
        width: 1424px;
        height: 880px;
    }

	.clearHex {
		/* fill: #a2ba79 */
		fill: white;
	}
</style>
</head>
<body>

<svg id="main" cursor="pointer"></svg>

<script type="module">
	import { Unit } from './Unit.js';
	import { Hex } from './Hex.js';
	import { SvgService } from './SvgService.js';
	import { 
		TerrainType, 
		PlayerType, 
		ColorByPlayer, 
		GameStatus, 
		TurnPhase, 
		SpecialPhaseType, 
		UnitProperties,
		MaxMovementPointCost,
		TerrainProperties
	} from './Constants.js';

	/*	
		TODO:
		- Move and attacks animations
		- Hyökkäys voi, johtaa perääntymiseen ja pelaaja saa valita perääntyvän yksikön
		- Samassa ruudussa voi olla monta yksikköä ja ruudun/yksikön klikkaaminen avaa valinta näkymän. Ehkä?
		- Special phase muutettava olioksi, jotta siihen liittyvät tiedot saadaan paremmin kytkettyä mukaan
	*/

	class GameState {
		constructor() {
			this.status = GameStatus.GAMEON;
			this.winner = null;
			this.activePlayer = PlayerType.GREY;
			this.currentTurnPhase = TurnPhase.MOVE;
			this.unassignedDamagePoints = 0;
			this.vacatedHex = null;
			this.specialPhaseQueue = [];
			this.crtColumn = null;
			this.d6Value = null;

			this.onCombatResultUpdated = [];
			this.onWinnerUpdated = [];
			this.onCurrentSpecialPhaseUpdated = [];
		}

		setCombatResult(crtColumn, d6Value) {
			this.crtColumn = crtColumn;
			this.d6Value = d6Value;
			this.triggerCombatResultUpdatedEvent();
		}
		
		triggerCombatResultUpdatedEvent() {
			this.onCombatResultUpdated.forEach(f => f());
		}

		setWinner(winner) {
			this.winner = winner;
			this.triggerWinnerUpdatedEvent();
		}

		triggerWinnerUpdatedEvent() {
			this.onWinnerUpdated.forEach(f => f());
		}

		getCurrentSpecialPhase() {
			return this.specialPhaseQueue.length > 0 ? this.specialPhaseQueue[0] : null;
		}

		triggerCurrentSpecialPhaseUpdatedEvent() {
			this.onCurrentSpecialPhaseUpdated.forEach(f => f());
		}

		pushSpecialPhaseQueue(specialPhase) {
			this.specialPhaseQueue.push(specialPhase);

			if (this.specialPhaseQueue.length > 0) {
				this.triggerCurrentSpecialPhaseUpdatedEvent();
			}
		}

		shiftSpecialPhaseQueue() {
			this.specialPhaseQueue.shift();
			this.triggerCurrentSpecialPhaseUpdatedEvent();
		}
	}

	class HexGrid {
		constructor(rows, cols, scenarioMap, hexRadius, lineWidth, gameState) {
			this.hexes = [];
			this.units = [];
			this.svg = null;
			this.rows = rows;
			this.cols = cols;
			this.scenarioMap = scenarioMap;
			this.hexRadius = hexRadius;
			this.lineWidth = lineWidth;
			this.selectedUnits = [];
			this.gameState = gameState;
		}

		async drawHexGrid() {
			const hexGrid = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
			hexGrid.setAttribute('id', 'hexGrid');
			const hexLayer = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
			hexLayer.setAttribute('id', 'hexLayer');
			const riverLayer = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
			riverLayer.setAttribute('id', 'riverLayer');
			const unitLayer = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
			unitLayer.setAttribute('id', 'unitLayer');

			const terrainMapHexes = this.scenarioMap.mapHexes.filter(mh => mh.terrain != TerrainType.CLEAR);
			const flagMapHexes = this.scenarioMap.mapHexes.filter(mh => mh.flag !== null && mh.flag !== undefined);
			const riverMapHexes = this.scenarioMap.mapHexes.filter(mh => Array.isArray(mh.riverEdges) && mh.riverEdges.length > 0);

			for (let row = 0; row < this.rows; row++) {
				for (let col = 0; col < this.cols; col++) {
					if ((row == this.rows - 1) && (col % 2 == 1)) {
						continue;
					}
					const hexWidth = getHexWidth(this.hexRadius);
					const xOffset = hexWidth * 0.75;
					const x = col * xOffset;
					const hexHeight = getHexHeight(this.hexRadius);
					const yOffset = hexHeight * 0.5;
					const y = row * hexHeight + ((col % 2) * yOffset);

					const hex = new Hex(col, row, this.hexRadius, this.lineWidth, this);

					const terrainType = terrainMapHexes.find(tmh => tmh.x === col && tmh.y === row)?.terrain ?? TerrainType.CLEAR;
					const flagHex = flagMapHexes.find(tmh => tmh.x === col && tmh.y === row) || {};
					const riverEdges = riverMapHexes.find(tmh => tmh.x === col && tmh.y === row)?.riverEdges ?? [];

					hex.setTerrain(terrainType);
					hex.setFlag(flagHex.flag, flagHex.player);
					hex.setRiverEdges(riverEdges);

					hex.svg.setAttribute('x', x);
					hex.svg.setAttribute('y', y);

					hex.svg.addEventListener('click', (function(hex) {
						return function() {
							hex.clickHandler();
						};
					})(hex));

					this.hexes.push(hex);
					hexLayer.appendChild(hex.svg);

					// Not in use
					// riverEdges.forEach(riverEdge => {
					// 	const riverSvg = this.drawRiver(getHexWidth(this.hexRadius) / 2 + 3.5, getHexHeight(this.hexRadius) / 2 + 3.5, riverEdge)
					// 	riverSvg.setAttribute('x', x - 2);
					// 	riverSvg.setAttribute('y', y - 2);
					// 	riverLayer.appendChild(riverSvg);
					// })
				}
			}

			hexGrid.appendChild(hexLayer);
			hexGrid.appendChild(riverLayer);
			hexGrid.appendChild(unitLayer);
			this.svg = hexGrid;
		}

		drawRiver(x, y, edge) {
			function calculateHexEdgePoints(x, y, radius, startVertex) {
				const startAngle = (Math.PI / 3) * startVertex;
				const endAngle = (Math.PI / 3) * (startVertex + 1);

				return [
					(x + radius * Math.cos(startAngle)) + "," + (y + radius * Math.sin(startAngle)),
					(x + radius * Math.cos(endAngle)) + "," + (y + radius * Math.sin(endAngle))
				]
			}

			const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
			polygon.setAttribute('points', calculateHexEdgePoints(x, y, 50, edge));
			polygon.setAttribute('fill', 'none');
			polygon.setAttribute('stroke', '#80c0ff');
			polygon.setAttribute('stroke-width', 7);

			const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
			svg.appendChild(polygon);

			return svg;
		}

		addUnit(unit) {
			this.units.push(unit);

			const unitLayer = this.svg.querySelector('#unitLayer');
			unitLayer.appendChild(unit.svg);
		}

		isEmpty(x, y) {
			return !this.units.some(unit => unit.x === x && unit.y === y) && this.hexes.some(hex => hex.x === x && hex.y === y && hex.isEmpty);
		}

		clearHighlightedHexes() {
			for(const highlightedHex of this.hexes.filter(hex => hex.highlighted)) {
				highlightedHex.toggleInnerHex(false);
			}
		}

		highlightAdjacentEnemyHexes(selectedUnits) {
			this.clearHighlightedHexes();

			let adjacentEnemyHexes = [];

			selectedUnits.forEach((su, index) => {
				const hexes = this.getAdjacentHexes(su.x, su.y)
					.filter(ah => this.units.some(unit => unit.x === ah.x && unit.y === ah.y && unit.player != this.gameState.activePlayer))
					.map(ah => this.hexes.find(h => h.x === ah.x && h.y === ah.y))

					index == 0 ? 
						adjacentEnemyHexes.push(...hexes) : 
						adjacentEnemyHexes = adjacentEnemyHexes.filter(value => hexes.includes(value));
			})

			for(const adjacentHex of adjacentEnemyHexes) {
				for(const hex of this.hexes) {
					if (adjacentHex.x == hex.x && adjacentHex.y == hex.y) {
						hex.toggleInnerHex(true);
					}
				}
			}
		}

		highlightReachableEmptyHexes(x, y, unitType) {
			 const adjacentHexes = this.getAdjacentEmptyHexesRecursion(x, y, 1, UnitProperties[unitType].movementAllowance); // old
			//const adjacentHexes = this.getReachableHex(x, y, UnitProperties[unitType].movementAllowance); // new

			for(const adjacentHex of adjacentHexes) {
				for(const hex of this.hexes) {
					if (adjacentHex.x == hex.x && adjacentHex.y == hex.y) {
						hex.toggleInnerHex();
					}
				}
			}
		}

		getAdjacentEmptyHexesRecursion(x, y, currentDepth, maxDepth) {
			const adjacentHexes = this.getAdjacentHexes(x, y).filter(ah => this.isEmpty(ah.x, ah.y));
			var allAdjacentHexes = [...adjacentHexes];

			if (currentDepth < maxDepth) {
				for(const adjacentHex of adjacentHexes) {
					const adjacentHexesRecursion =
						this.getAdjacentEmptyHexesRecursion(adjacentHex.x, adjacentHex.y, currentDepth + 1, maxDepth)
						.filter(ah => !(ah.x == x && ah.y == y));

					allAdjacentHexes.push(...adjacentHexesRecursion);
				}
			}

			if (currentDepth === 1 && maxDepth > 1)
			{
				allAdjacentHexes = Array.from(new Set(allAdjacentHexes.map(JSON.stringify)), JSON.parse);
			}

			return allAdjacentHexes;
		}

		dfs(x, y, movementPoints, visited, reachableHexes) {
			if (visited.find(v => v.x === x && v.y === y && v.movementPoints >= movementPoints) != null) {
				return;			
			}

			const cost = !this.units.some(unit => unit.x === x && unit.y === y) 
				? TerrainProperties[this.getHex(x, y).terrainType].movementPointCost
				: MaxMovementPointCost

			if (movementPoints < cost)
			{
				visited.push({x: x, y: y, movementPoints: movementPoints});
				return;
			}
			
			visited.push({x: x, y: y, movementPoints: movementPoints});

			if (!reachableHexes.some(rh => rh.x === x && rh.y === y)) {
				reachableHexes.push({ x: x, y: y });
			}

			const remainingPoints = movementPoints - cost;
			const adjacentHexes = this.getAdjacentHexes(x, y);
			adjacentHexes.forEach(ah => this.dfs(ah.x, ah.y, remainingPoints, visited, reachableHexes));
		}

		getReachableHex(x, y, movementPoints) {
			const reachableHexes = [];
			const visited = [];
		  
			visited.push({x: x, y: y, movementPoints: movementPoints});
		  
			const adjacentHexes = this.getAdjacentHexes(x, y);
			adjacentHexes.forEach(ah => this.dfs(ah.x, ah.y, movementPoints, visited, reachableHexes));
					
			return reachableHexes;
		}

		getAdjacentHexes(x, y) {
			const adjacentHexes = [];

			const isWithinGridBounds = (x, y) => 
				x >= 0 &&
				x < this.cols &&
				y >= 0 &&
				y < this.rows &&
				!((y == this.rows - 1) && (x % 2 == 1));

			const offsetsOddRow = [
				[0, -1], [1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0]
			];

			const offsetsEvenRow = [
				[0, -1], [1, -1], [1, 0], [0, 1], [-1, 0], [-1, -1]
			];

			const offsets = x % 2 === 0 ? offsetsEvenRow : offsetsOddRow;
			return offsets.filter(([dx, dy]) => {
				return isWithinGridBounds(x + dx, y + dy);
			}).map(([dx, dy]) => ({ x: x + dx, y: y + dy }));
		}

		getHex(x, y) {
			return this.hexes.find(h => h.x === x && h.y === y);
		}

		clearSelections() {			
			this.selectedUnits.forEach(su => su.selected = false)
			this.selectedUnits = [];

			this.refreshUnitSelectRects();
		}

		refreshUnitDimmers() {
			this.units.forEach(u => u.refreshDimmer());
		}

		refreshUnitSelectRects() {
			this.units.forEach(u => u.refreshSelectRect());
		}

		clearUnitMovedAttacked() {
			this.units.forEach(u => {
				u.moved = false;
				u.attacked = false;
				u.advanced = false;
				u.refreshDimmer();
			});
		}

		checkWinningConditions() {		
			const winner = this.getWinner();

			if (winner != null) {
				this.gameState.status = GameState.ENDED;
				this.gameState.setWinner(winner);
			}
		}

		getWinner() {
			for (const player of Object.values(PlayerType)) {
				if (!this.units.some(u => u.player == getAnotherPlayer(player)))
				{
					return player;
				}

				const flagHex = this.hexes.find(h => h.flag != null && h.player == getAnotherPlayer(player));			
				if (this.units.some(u => u.x === flagHex.x && u.y === flagHex.y && u.player === player)) {
					return player;
				}
			}

			return null;
		}

		removeDeadUnits() {
			[...this.units]
					.filter(u => u.isDead())
					.forEach(u => u.remove());
		}

		startSpecialPhase(specialPhase) {
			if (specialPhase === SpecialPhaseType.ADVANCE) {
				if (this.gameState.attackers.every(a => a.isDead())) {
					this.endSpecialPhase();
				}
				else {
					this.clearHighlightedHexes();
					this.gameState.vacatedHex.toggleInnerHex(true);
					this.refreshUnitDimmers();
				}
			}
		}

		endSpecialPhase() {
			if(this.gameState.getCurrentSpecialPhase() === SpecialPhaseType.ADVANCE) {
				this.clearHighlightedHexes();
				this.clearSelections();
			}

			this.gameState.shiftSpecialPhaseQueue();

			this.refreshUnitDimmers();
			this.startSpecialPhase(this.gameState.getCurrentSpecialPhase());
		}
	}

	class ScenarioMap {
		constructor() {
			this.mapHexes = [];
		}

		async load(mapFile){
			try {
				const response = await fetch(mapFile);

				if (!response.ok) {
					throw new Error('Tiedoston lataaminen epäonnistui');
				}

				const jsonData = await response.json();

				this.mapHexes = jsonData.map((hexData) => {
					const mapHex = new MapHex();
					mapHex.x = hexData.x;
					mapHex.y = hexData.y;
					mapHex.terrain = hexData.terrain;
					mapHex.unit = hexData.unit;
					mapHex.player = hexData.player;
					mapHex.riverEdges = hexData.riverEdges;
					mapHex.flag = hexData.flag;
					return mapHex;
				});
			} catch (error) {
				console.error('Virhe karttatiedoston lataamisessa:', error.message);
				return null;
			}
		}
	}

	class MapHex {
		constructor() {
			this.x = null;
			this.y = null;
			this.terrain = null;
			this.unit = null;
			this.player = null;
			this.riverEdges = null;
		}
	}

	class InfoArea {
		constructor(gameState, hexGrid) {
			this.gameState = gameState;
			this.hexGrid = hexGrid;
			this.svg = null;

			this.gameState.onCombatResultUpdated.push(this.refreshCombatResultText.bind(this));
			this.gameState.onWinnerUpdated.push(this.refreshStatusText.bind(this));
			this.gameState.onCurrentSpecialPhaseUpdated.push(this.updatePhaseText.bind(this));
			this.gameState.onCurrentSpecialPhaseUpdated.push(this.refreshStatusText.bind(this));
			this.gameState.onCurrentSpecialPhaseUpdated.push(this.refreshEndPhaseButton.bind(this));
		}

		updatePhaseText() {			
			let currentPhase = null;

			const currentSpecialPhase = this.gameState.getCurrentSpecialPhase();

			if (currentSpecialPhase === SpecialPhaseType.ADVANCE) {
				currentPhase = currentSpecialPhase.toUpperCase();
			}
			else if (currentSpecialPhase === SpecialPhaseType.ATTACKER_DAMAGE) {
				currentPhase = "assign".toUpperCase();
			}
			else {
				currentPhase = this.gameState.currentTurnPhase.toUpperCase();
			}

			this.svg.querySelector('.phase').textContent = "PHASE: " + currentPhase;
		}

		updatePlayerText() {
			this.svg.querySelector('.turn').textContent = "PLAYER: " + this.gameState.activePlayer.toUpperCase();
		}

		refreshCombatResultText() {
			const value = this.gameState.crtColumn != null && this.gameState.d6Value != null 
				? this.gameState.crtColumn.ratioText + ", " + 
				  this.gameState.d6Value + ", " + 
				  this.gameState.crtColumn[this.gameState.d6Value]
				: '-';

			this.svg.querySelector('.combatResult').textContent = "COMBAT: " + value;
		}

		refreshStatusText() {
			const statusText = this.svg.querySelector('.statusText');

			if (this.gameState.winner !== null) {
				statusText.textContent = this.gameState.winner.toUpperCase() + " PLAYER WON";
			}
			else if (this.gameState.getCurrentSpecialPhase() === SpecialPhaseType.ATTACKER_DAMAGE) {
				statusText.textContent = `Assign damage to attacker, ${this.gameState.unassignedDamagePoints} left`;
			}
			else if (this.gameState.getCurrentSpecialPhase() === SpecialPhaseType.ADVANCE) {
				statusText.textContent = `Advance to vacated hex?`;
			}
			else {
				statusText.textContent = "";
			}
		}

		refreshEndPhaseButton() {
			const endPhaseButtonText = this.svg.querySelector('.endPhaseButton .buttonText');

			const currentSpecialPhase = this.gameState.getCurrentSpecialPhase();
			const color = currentSpecialPhase === SpecialPhaseType.ATTACKER_DAMAGE ? "grey" : "black";
			endPhaseButtonText.setAttribute('fill', color);
		}

		endPhase() {
			if (this.hexGrid.gameState.status !== GameStatus.GAMEON) {
				return;
			}

			const currentSpecialPhase = this.gameState.getCurrentSpecialPhase();

			if (currentSpecialPhase === SpecialPhaseType.ADVANCE) {
				this.hexGrid.endSpecialPhase();
			}
			else if (currentSpecialPhase === null) {
				if (this.gameState.currentTurnPhase == TurnPhase.MOVE) {
					this.gameState.currentTurnPhase = TurnPhase.ATTACK;
					this.updatePhaseText();
				}
				else if (this.gameState.currentTurnPhase == TurnPhase.ATTACK) {
					this.gameState.activePlayer = this.gameState.activePlayer == PlayerType.GREY
						? this.gameState.activePlayer = PlayerType.GREEN
						: this.gameState.activePlayer = PlayerType.GREY;

					this.gameState.currentTurnPhase = TurnPhase.MOVE;

					this.gameState.setCombatResult(null, null);
					this.updatePhaseText();
					this.updatePlayerText();
					this.hexGrid.clearUnitMovedAttacked();
				}

				this.hexGrid.clearHighlightedHexes();
				this.hexGrid.clearSelections();
				this.hexGrid.refreshUnitDimmers();
			}
		}

		draw() {
			this.svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');

			const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
			text.setAttribute('fill', 'black');
			text.setAttribute('font-family', "Arial, sans-serif");
			text.setAttribute('font-size', '22px');
			text.style.userSelect = 'none';
	
			const x = 1050;
			const y = 50;

			const tspan1 = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
			tspan1.textContent = "PLAYER: " + this.gameState.activePlayer.toUpperCase();
			tspan1.setAttribute('x', x);
			tspan1.setAttribute('dy', '1.2em');
			tspan1.setAttribute('class', 'turn');

			const tspan2 = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
			tspan2.textContent = "PHASE: " + this.gameState.currentTurnPhase.toUpperCase();
			tspan2.setAttribute('class', 'phase');	
			tspan2.setAttribute('x', x);
			tspan2.setAttribute('dy', '1.2em');

			const tspan3 = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
			tspan3.textContent = "COMBAT: -";
			tspan3.setAttribute('class', 'combatResult');	
			tspan3.setAttribute('x', x);
			tspan3.setAttribute('dy', '1.2em');

			text.appendChild(tspan1);
			text.appendChild(tspan2);
			text.appendChild(tspan3);

			text.setAttribute('y', y);

			this.svg.appendChild(text);
			
			const buttonSVG = this.createButtonSVG(100, 30, "End phase");
			buttonSVG.setAttribute('class', 'endPhaseButton');	
			buttonSVG.setAttribute('x', x);
			buttonSVG.setAttribute('y', y + 100);

			this.svg.appendChild(buttonSVG);

			const handleClick = () => {
				this.endPhase();
			};

			buttonSVG.addEventListener('click', () => this.endPhase());

			const statusText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
			statusText.setAttribute('fill', 'black');
			statusText.setAttribute('font-family', "Arial, sans-serif");
			statusText.setAttribute('font-size', '22px');
			statusText.style.userSelect = 'none';
			statusText.textContent = ""
			statusText.setAttribute('class', 'statusText');	
			statusText.setAttribute('x', x);
			statusText.setAttribute('y', y + 170);

			this.svg.appendChild(statusText);
		}

		createButtonSVG(width, height, text) {
			const svgNS = "http://www.w3.org/2000/svg";
			const svg = document.createElementNS(svgNS, "svg");
			
			svg.setAttribute("width", width + 4);
			svg.setAttribute("height", height + 4);

			const rect = document.createElementNS(svgNS, "rect");
			rect.setAttribute("x", 2);
			rect.setAttribute("y", 2);
			rect.setAttribute("width", width);
			rect.setAttribute("height", height);
			rect.setAttribute("fill", "#ebf2fa");
			rect.setAttribute("rx", 5);
			rect.setAttribute('stroke', 'black');
			rect.setAttribute('stroke-width', 2);

			const buttonText = document.createElementNS(svgNS, "text");
			buttonText.setAttribute("x", width / 2 + 2);
			buttonText.setAttribute("y", height / 2 + 2);
			buttonText.setAttribute("class", "buttonText");
			buttonText.setAttribute("dominant-baseline", "middle");
			buttonText.setAttribute("text-anchor", "middle");
			buttonText.setAttribute("font-family", "Arial");
			buttonText.setAttribute("font-size", "16px");
			buttonText.style.userSelect = 'none';
			buttonText.textContent = text;

			svg.appendChild(rect);
			svg.appendChild(buttonText);
			svg.setAttribute("x", 10);
			svg.setAttribute("y", 10);

			return svg;
		}
	}

	async function drawGame() {
		const svg = document.getElementById('main');
		const hexRadius = 50;
		const numCols = 13;
		const numRows = 9;
		const lineWidth = 2;

		const svgService = new SvgService();
		await svgService.load();

		const scenarioMap = new ScenarioMap();
		await scenarioMap.load("map01.json");

		const gameState = new GameState();

		const hexGrid = new HexGrid(numRows, numCols, scenarioMap, hexRadius, lineWidth, gameState);
		await hexGrid.drawHexGrid();

		svg.appendChild(hexGrid.svg);

		scenarioMap.mapHexes.filter(mh => mh.unit !== null && mh.unit !== undefined).forEach(mh => {
			const svgElement = svgService.svgElements[mh.unit + ".svg"];
			const unit = new Unit(mh.x , mh.y, mh.unit, svgElement.cloneNode(true), mh.player, hexRadius, lineWidth, hexGrid, gameState);
			unit.createUnit();
			hexGrid.addUnit(unit);
		})

		const infoArea = new InfoArea(gameState, hexGrid);
		infoArea.draw();
		svg.appendChild(infoArea.svg);
	}

	function getHexWidth(hexRadius) {
		return 2 * hexRadius;
	}

	function getHexHeight(hexRadius) {
		return Math.sqrt(3) * hexRadius;
	}


	function getAnotherPlayer(player) {
		return player === PlayerType.GREEN ? PlayerType.GREY : PlayerType.GREEN;
	}

    window.onload = drawGame;
</script>

</body>
</html>
